import urllib.request
import urllib.error
import json
import time
import concurrent.futures
import random

# Configuration
BASE_URL = "http://localhost:8080/api"
USERNAME = "admin"
PASSWORD = "admin"
NUM_REQUESTS = 1000
CONCURRENCY = 10

def login():
    url = f"{BASE_URL}/auth/login"
    data = json.dumps({"username": USERNAME, "password": PASSWORD}).encode('utf-8')
    req = urllib.request.Request(url, data=data, headers={'Content-Type': 'application/json'})
    
    try:
        with urllib.request.urlopen(req) as response:
            if response.status == 200:
                body = json.loads(response.read().decode('utf-8'))
                return body['token']
    except urllib.error.URLError as e:
        print(f"Login failed: {e}")
        return None

def create_job(token, job_id):
    url = f"{BASE_URL}/jobs"
    job_name = f"Stress Test Job {job_id}"
    
    payload = {
        "name": job_name,
        "owner": "stress_tester",
        "type": "SHELL_SCRIPT",
        "description": "Generated by stress test",
        "jobData": json.dumps({"script": "echo 'Stress test running'"}),
        "isRecurring": False,
        "maxRetries": 0
    }
    
    data = json.dumps(payload).encode('utf-8')
    req = urllib.request.Request(url, data=data, headers={
        'Content-Type': 'application/json',
        'Authorization': f"Bearer {token}"
    })
    
    start_time = time.time()
    try:
        with urllib.request.urlopen(req) as response:
            duration = (time.time() - start_time) * 1000
            return response.status, duration
    except urllib.error.HTTPError as e:
        return e.code, 0
    except Exception as e:
        print(f"Request failed: {e}")
        return 0, 0

def run_stress_test():
    print("Starting stress test...")
    
    # 1. Login
    print("Authenticating...")
    token = login()
    if not token:
        print("Could not obtain token. Exiting.")
        return

    print(f"Authenticated. Token obtained.")
    print(f"Simulating {NUM_REQUESTS} requests with concurrency {CONCURRENCY}...")

    success_count = 0
    fail_count = 0
    total_duration = 0
    
    start_time = time.time()
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=CONCURRENCY) as executor:
        futures = [executor.submit(create_job, token, i) for i in range(NUM_REQUESTS)]
        
        for future in concurrent.futures.as_completed(futures):
            status, duration = future.result()
            if status == 201:
                success_count += 1
                total_duration += duration
            else:
                fail_count += 1

    end_time = time.time()
    total_time = end_time - start_time
    
    print("\n--- Stress Test Results ---")
    print(f"Total Requests: {NUM_REQUESTS}")
    print(f"Successful: {success_count}")
    print(f"Failed: {fail_count}")
    print(f"Total Time: {total_time:.2f} seconds")
    print(f"Requests/sec: {NUM_REQUESTS / total_time:.2f}")
    if success_count > 0:
        print(f"Avg Latency: {total_duration / success_count:.2f} ms")

if __name__ == "__main__":
    run_stress_test()
